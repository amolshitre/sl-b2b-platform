/**
 * Dbs.java
 *
 * This file was generated by MapForce 2011sp1.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the MapForce Documentation for further details.
 * http://www.altova.com/mapforce
 */

package com.altova.db;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.HashMap;
import com.altova.mapforce.IEnumerable;
import com.altova.mapforce.IMFNode;
import com.altova.mapforce.MFEmptySequence;
import com.altova.mapforce.MFSingletonSequence;
import com.altova.types.CalendarBase;
import com.altova.types.DateTime;
import com.altova.types.Duration;
import com.altova.types.StringParseException;

public class Dbs 
{
	public static IEnumerable readField(Record record, String name)
	{
		if (!record.containsKey(name))
			throw new UnsupportedOperationException("Column \"" + name + "\" not found in record"); 
			
		return record.get(name);
	}
	
	public static void bindParameter_String(Statement command, String value) throws Exception
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_BigDecimal(Statement command, BigDecimal value) throws Exception
	{
		command.bindParameter(value, value.scale());
	}
	
	public static void bindParameter_DateTime(Statement command, DateTime value) throws Exception
	{
		/*
		java.util.Calendar cal = java.util.Calendar.getInstance();
		long tzoffset = cal.get(java.util.Calendar.ZONE_OFFSET);
		long datetime = value.getValue().getTimeInMillis()-tzoffset;
		command.bindParameter(new java.sql.Timestamp(datetime));
		*/
		command.bindParameter(new java.sql.Timestamp(value.getValue().getTimeInMillis()));
	}
	
	public static void bindParameter_Time(Statement command, DateTime value) throws Exception
	{
		java.util.Calendar cal = java.util.Calendar.getInstance();
		long tzoffset = cal.get(java.util.Calendar.ZONE_OFFSET);
		value.setYear(1970); value.setMonth(1); value.setDay(1);
		long time = value.getValue().getTimeInMillis()-tzoffset;
		command.bindParameter(new java.sql.Time(time));
	}

	public static void bindParameter_long(Statement command, long value) throws Exception
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_int(Statement command, int value) throws Exception
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_boolean(Statement command, Object value)
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_binary(Statement command, Object value)
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_BigInteger(Statement command, Object value)
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_double(Statement command, Object value)
	{
		command.bindParameter(value);
	}

	public static void addParameter(Statement command, int type, int length)
	{
		command.addParameter(type, length);
	}
	
	public static void prepareStatement(Statement command)
	{
	}
	
	public static void storeStatement(Statement command)
	{
	}
	
	public static Statement newStatement(Catalog catalog, int id, String statement) throws Exception
	{
		return catalog.createStatement(id, statement);
	}
	
	public static Statement newQuery(Catalog catalog, int id)
	{
		Statement statement = catalog.getStatement(id);
		statement.clear();
		return statement;
	}
	
	public static ResultSetWrapper executeQuery(Statement query) throws Exception
	{
		return query.execute();
	}
	
	static public Record newRecord()
	{
		return new Record();
	}
	
	static public boolean moveNextRecord(ResultSetWrapper recordset)throws Exception
	{
		return recordset.getResultSet().next();
	}
	
	static public void disposeRecordset(ResultSetWrapper recordset) throws Exception
	{
		recordset.close();
	}
	
	public static void disposeQuery(Statement query) throws Exception
    {
        query.close();
    }
	
	// KBFs
	
	public static void read_boolean(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		Boolean value = (Boolean) recordset.getResultSet().getObject(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		record.put(name, new MFSingletonSequence(value.booleanValue()));
	}
	
	public static void read_byte(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		record.put(name, new MFSingletonSequence(value.intValue()));
	}
	
	public static void read_short(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		record.put(name, new MFSingletonSequence(value.intValue())); 
	}
	
	public static void read_int(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		record.put(name, new MFSingletonSequence(value.intValue()));
	}
	
	public static void read_long(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		record.put(name, new MFSingletonSequence(value.longValue()));
	}
	
	public static void read_float(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		record.put(name, new MFSingletonSequence(value.floatValue()));
	}
	
	public static void read_double(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		record.put(name, new MFSingletonSequence(value.doubleValue()));
	}
	
	public static void read_BigDecimal(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		BigDecimal value = (BigDecimal) recordset.getResultSet().getObject(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		record.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_BigInteger(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		BigInteger value = (BigInteger) recordset.getResultSet().getObject(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		record.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_DateTime(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		Object obj = recordset.getResultSet().getObject(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		DateTime value = null;
		
		if (obj instanceof java.sql.Timestamp)
			value = timestampToDateTime((java.sql.Timestamp)obj);
			
		if(obj instanceof java.sql.Date)
			value = timestampToDateTime((java.sql.Date) obj);
		
		if(obj instanceof java.sql.Time)
			value = timestampToDateTime((java.sql.Time) obj);

		if(obj instanceof java.lang.String)
			value = DateTime.parse((java.lang.String) obj);
		
		record.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_String(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		String str = recordset.getResultSet().getString(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		record.put(name, new MFSingletonSequence(str));
	}
	
	public static void read_binary(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		byte[] blob = recordset.getResultSet().getBytes(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull() || blob == null) 
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		record.put(name, new MFSingletonSequence(blob));
	}
	
	public static void read_blob(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		read_binary(record, recordset, name);
	}

	public static void read_binary_MySQL(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		java.io.InputStream is = recordset.getResultSet().getBinaryStream(record.getCurrentColumn());
		java.io.ByteArrayOutputStream os = new java.io.ByteArrayOutputStream();
		
		int v;
		while( (v = is.read()) != -1 )
			os.write(v);

		byte[] blob = os.toByteArray(); 

		if( (recordset.getResultSet().wasNull()) || (blob.length == 0) ) 
		{
			record.put(name, new MFEmptySequence());
			return;
		}

		record.put(name, new MFSingletonSequence(blob));
	}
	
	public static void read_String_ParseDate(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		String str = recordset.getResultSet().getString(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
				
		DateTime value = new DateTime();
		value.parseDate(str.trim());
		record.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_String_ParseTime(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		String str = recordset.getResultSet().getString(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
				
		DateTime value = new DateTime();
		value.parseTime(str.trim());
		record.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_String_ParseTimeTZ_PostgreSQL(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		String str = recordset.getResultSet().getString(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
				
		int optional = CalendarBase.DateTimePart_TimezoneMinute;

		DateTime value = new DateTime();
		value.parseTime(str.trim(), optional);
		record.put(name, new MFSingletonSequence(value));
	}

	public static void read_String_ParseDateTime(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		String str = recordset.getResultSet().getString(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		DateTime value = new DateTime();
		value.parseDateTime(str.trim(), CalendarBase.DateTimePart_Date | CalendarBase.DateTimePart_Time);
		record.put(name, new MFSingletonSequence(value));
	}

	public static void read_String_ParseDecimal(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		String str = recordset.getResultSet().getString(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		BigDecimal value = new BigDecimal(str.trim());
		record.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_binary_Bitfield_MySQL(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		byte[] blob = recordset.getResultSet().getBytes(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull() || blob == null)
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		BigInteger value = new BigInteger( blob ); 
		record.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_long_BuildBigInteger_MySQL(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		Object obj = recordset.getResultSet().getObject(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		BigInteger value = new BigInteger(obj.toString()); 
		record.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_Decimal_Oracle(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		Number number = (Number) recordset.getResultSet().getObject(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}	
		
		BigDecimal value = null;
		if( number instanceof BigDecimal )
			value = (BigDecimal)(number);
		else
			value = BigDecimal.valueOf(number.doubleValue());
		
		record.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_String_ParseIntervalYearToMonth_Oracle(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		String str = recordset.getResultSet().getString(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		Duration.RefInt n = new Duration.RefInt(0);  
		CalendarBase.ParseContext context = new Duration.ParseContext(str.trim());
		String err = str + " cannot be converted to a duration value.";
		
        boolean positive = true; // parse sign
        if( context.checkAndAdvance('-') ) positive = false;
        else if( context.checkAndAdvance('+') ) positive = true;
        else throw new StringParseException(err + "Invalid or missing sign.",2);
        if (!context.isValid()) throw new StringParseException(err,2);

        int years = 0; // parse year component
        while(context.readDigitAndAdvance(n, 1, 9)) { years = (years * 10) + n.value; n.value = 0; }

        // check year-month divider
        if (!context.isValid()) throw new StringParseException(err + "Missing year-month divider.",2);
        if (!context.checkAndAdvance('-')) throw new StringParseException(err + "Invalid year-month divider.",2);
        if (!context.isValid()) throw new StringParseException(err + "Missing month value.",2);

        int month = 0;// parse month component
        while(context.readDigitAndAdvance(n, 1, 9)) { month = (month * 10) + n.value; n.value = 0; }

        Duration duration = new Duration(years, month, 0, 0, 0, 0, 0.0, !positive );
		record.put(name, new MFSingletonSequence(duration));
	}
	
	public static void read_String_ParseIntervalDayToSecond_Oracle(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		String str = recordset.getResultSet().getString(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		Duration.RefInt n = new Duration.RefInt(0); 
		CalendarBase.ParseContext context = new Duration.ParseContext(str.trim());
		String err = str + " cannot be converted to a duration value.";
		
        boolean positive = true; // parse sign
        if( context.checkAndAdvance('-') ) positive = false;
        else if( context.checkAndAdvance('+') ) positive = true;
        else throw new StringParseException(err,2);
        if (!context.isValid()) throw new StringParseException(err,2);

        int days = 0; // parse day component
        while(context.readDigitAndAdvance(n, 1, 9)) { days = (days * 10) + n.value; n.value = 0; }
        if (!context.isValid()) throw new StringParseException(err,2);

        // check days-time divider
        if (!context.checkAndAdvance(' ')) throw new StringParseException(err,2);
        if (!context.isValid()) throw new StringParseException(err,2);

        String isotime = str.substring( context.index() );// parse hours:minutes:seconds.fraction 
        DateTime time = new DateTime();
        time.parseTime(isotime);
 
        Duration duration = new Duration(0, 0, days, time.getHour(), time.getMinute(), time.getSecond(), time.getMillisecond()/1000.0, !positive );
		record.put(name, new MFSingletonSequence(duration));
	}
	
	public static void read_String_ParseInterval_PostgreSQL(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		String str = recordset.getResultSet().getString(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		
        // Format: YYYY/MM/DD/hh/mm/ss.ff9

        boolean positive = true;
        double fraction = 0.0;

		Duration.RefInt n = new Duration.RefInt(0); 
		CalendarBase.ParseContext context = new Duration.ParseContext(str.trim());
		String err = str + " cannot be converted to a duration value.";

        int years = 0; // parse year component
        if( context.checkAndAdvance('-') ) positive = false;
        if (!context.isValid()) throw new StringParseException(err,2);
        while(context.readDigitAndAdvance(n, 1, 9)) { years = (years * 10) + n.value; n.value = 0; }
        if (!context.isValid()) throw new StringParseException(err,2);

        if(!context.checkAndAdvance('/')) throw new StringParseException(err,2);
        
        int month = 0; // parse month component
        if( context.checkAndAdvance('-') ) positive = false;
        if (!context.isValid()) throw new StringParseException(err,2);
        while(context.readDigitAndAdvance(n, 1, 9)) { month = (month * 10) + n.value; n.value = 0; }
        if (!context.isValid()) throw new StringParseException(err,2);
        
        if(!context.checkAndAdvance('/')) throw new StringParseException(err,2);

        int days = 0; // parse days component
        if( context.checkAndAdvance('-') ) positive = false;
        if (!context.isValid()) throw new StringParseException(err,2);
        while(context.readDigitAndAdvance(n, 1, 9)) { days = (days * 10) + n.value; n.value = 0; }
        if (!context.isValid()) throw new StringParseException(err,2);
        
        if(!context.checkAndAdvance('/')) throw new StringParseException(err,2);

        int hours = 0; // parse hour component
        if( context.checkAndAdvance('-') ) positive = false;
        if (!context.isValid()) throw new StringParseException(str,2);
        while(context.readDigitAndAdvance(n, 1, 9)) { hours = (hours * 10) + n.value; n.value = 0; }
        if (!context.isValid()) throw new StringParseException(str,2);

        if(!context.checkAndAdvance('/')) throw new StringParseException(str,2);

        int minutes = 0; // parse minute component
        if( context.checkAndAdvance('-') ) positive = false;
        if (!context.isValid()) throw new StringParseException(str,2);
        while(context.readDigitAndAdvance(n, 1, 9)) { minutes = (minutes * 10) + n.value; n.value = 0; }
        if (!context.isValid()) throw new StringParseException(str,2);

        if(!context.checkAndAdvance('/')) throw new StringParseException(str,2);

        int seconds = 0; // parse seconds component
        if( context.checkAndAdvance('-') ) positive = false;
        if (!context.isValid()) throw new StringParseException(str,2);
        while(context.readDigitAndAdvance(n, 1, 9)) { seconds = (seconds * 10) + n.value; n.value = 0; }
        if(!context.isValid()) throw new StringParseException(str,2);
        if( context.checkAndAdvance('.') )
        {
        	int temp = 0; // microseconds
        	if(!context.isValid()) throw new StringParseException(str,2);
            while (context.readDigitAndAdvance(n, 1, 9)) { temp = (temp * 10) + n.value; n.value = 0; }
            fraction = temp / 1000000.0;
        }
        
        Duration duration = new Duration(years, month, days, hours, minutes, seconds, fraction, !positive );
		record.put(name, new MFSingletonSequence(duration));
	}

	private static String internalFormatGUID(byte[] bytes)
	{	
		if( (bytes == null) || ((bytes != null) && bytes.length == 0) ) 
			return null; // sanity check
		
		byte[] hexchars = {
			'0', '1', '2', '3', '4', '5',
			'6', '7', '8', '9', 'a', 'b',
			'c', 'd', 'e', 'f'
		};
		Boolean curly = true;
		int n = (2 * bytes.length) + 4 + (curly ? 2 : 0);
		StringBuilder s = new StringBuilder(n);
		if( curly ) s.append('{');//prefix
		for (int i = 0; i < bytes.length; i++) 
		{
			int v = bytes[i] & 0xff;
			s.append((char)hexchars[v >> 4]);
			s.append((char)hexchars[v & 0xf]);
			if( i==3 || i==5 || i==7 || i==9)
				s.append('-');//separator 
		}
		if( curly ) s.append('}');//suffix
		return s.toString().toUpperCase();			
	}

	public static void read_binary_BuildGuidString(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		byte[] blob = recordset.getResultSet().getBytes(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull() || blob == null)
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		byte[] buf = new byte[8];
		
		buf[0] = blob[3];	buf[1] = blob[2];	buf[2] = blob[1];	buf[3] = blob[0];
		buf[4] = blob[5];	buf[5] = blob[4];	buf[6] = blob[7];	buf[7] = blob[6];

		blob[0] = buf[0];	blob[1] = buf[1];	blob[2] = buf[2];	blob[3] = buf[3];
		blob[4] = buf[4];	blob[5] = buf[5];	blob[6] = buf[6];	blob[7] = buf[7];

		String value = internalFormatGUID( blob );
		record.put(name, new MFSingletonSequence(value));
	}

	public static void read_string_BuildGuidString(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		String value = recordset.getResultSet().getString(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		if( !value.startsWith("{")) value = "{" + value;
		if( !value.endsWith("}")) value = value + "}";
		record.put(name, new MFSingletonSequence(value.toUpperCase()));
	}

	public static void read_int_Boolean_PostgreSQL(Record record, ResultSetWrapper recordset, String name) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(record.getCurrentColumn());
		
		if (recordset.getResultSet().wasNull())
		{
			record.put(name, new MFEmptySequence());
			return;
		}
		
		record.put(name, new MFSingletonSequence((boolean)(value.intValue()!=0)));
	}
	
	// Helper functions
	
	private static com.altova.types.DateTime timestampToDateTime(java.util.Date ts)
	{
		if (ts == null)
			return null;
			
		java.util.Calendar cal = java.util.Calendar.getInstance();
		cal.setTimeInMillis(ts.getTime());
		return new com.altova.types.DateTime(cal);
	}
}
