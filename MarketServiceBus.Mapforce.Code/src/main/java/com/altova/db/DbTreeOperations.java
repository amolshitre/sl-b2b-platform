/**
 * DbTreeOperations.java
 *
 * This file was generated by MapForce 2011sp1.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the MapForce Documentation for further details.
 * http://www.altova.com/mapforce
 */

package com.altova.db;

import java.sql.ResultSet;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.Savepoint;
import com.altova.typeinfo.MemberInfo;
import java.util.Hashtable;

public class DbTreeOperations
{
	
	public static class ReadBack 
	{
		String name;
		
		public ReadBack(String name)
		{
			this.name = name;
		}			
		
		public String getName() 
		{
			return name;
		}
	}
	
	public static class TransactionSentinel
	{
		private TransactionHelper tr;
		private String name;
			
		public TransactionSentinel (TransactionHelper t, String name) throws java.sql.SQLException
		{
			tr = t;
			this.name = name;
			tr.beginTrans(name);
		}
		
		public void commit() throws java.sql.SQLException
		{
			tr.commitTrans();
			tr = null;
		}
		
		public void rollback() throws java.sql.SQLException
		{
			if (tr != null)
				tr.rollbackTrans(name);
		}	
	}
	
	public static class TransactionHelper
	{
		String beginTrans;
		String commitTrans;
		String rollbackTrans;
		String setSavepoint;
		String rollbackSavepoint;
		java.util.HashMap savepoints;
		Connection connection;
		int depth;

		public TransactionHelper(Connection conne, String begin, String commit,	String rollback,
			String save, String rollbackSave)
		{
			connection = conne;
			beginTrans = begin;
			commitTrans = commit;
			rollbackTrans = rollback;
			setSavepoint = save;
			rollbackSavepoint = rollbackSave;
			depth = 0;
			savepoints = new java.util.HashMap();
		}
		
		private void executeCommandString(String s) throws java.sql.SQLException
		{
			PreparedStatement statement = connection.prepareStatement(s);
			try
			{
				statement.execute();
			}
			finally
			{
				statement.close();
			}
		}
		
		private void executeCommandString(String s, String replaceName) throws java.sql.SQLException
		{
			int i = s.indexOf(" %%TRANSACTION_NAME%% ");
			if (i == -1)
				executeCommandString(s);
			else
				executeCommandString(s.substring(0, i) + replaceName + s.substring(i+22, s.length()));
		}
		
		public void beginTrans(String transName) throws java.sql.SQLException
		{
			// System.out.println("TransHelper: beginning trans \"" + transName + "\""); 
			if (depth == 0)
			{
				try { connection.setAutoCommit(false); }
				catch (java.sql.SQLException e) { }
				
			//	if (beginTrans.length() != 0)
			//		executeCommandString(beginTrans);
			}
			else
			{
				if (setSavepoint.length() != 0)
					executeCommandString(setSavepoint, transName);
			//	else
			//		savepoints.put(transName, connection.setSavepoint(transName));
			}
			++depth;
		}
		
		public void commitTrans() throws java.sql.SQLException
		{
			// System.out.println("TransHelper: commiting ");
			--depth;
			if (depth == 0)
			{
				connection.commit();
				
			//	if (beginTrans.length() == 0)
			//		connection.commit();
			//	else
			//		executeCommandString(commitTrans);
					
			//	try { connection.setAutoCommit(true); }
			//	catch (java.sql.SQLException e) { }	
			}
		}
		
		public void rollbackTrans(String transName)  throws java.sql.SQLException
		{
			// System.out.println("TransHelper: rolling back \"" + transName + "\"");
			--depth;
			if (depth == 0)
			{
				connection.rollback();
				
			//	if (beginTrans.length() == 0)
			//		connection.rollback();
			//	else
			//		executeCommandString(rollbackTrans);
			//	try {
			//		connection.setAutoCommit(true);
			//	}
			//	catch (java.sql.SQLException e) {}	
			}
			else
			{
				if (rollbackSavepoint.length() != 0)
					executeCommandString(rollbackSavepoint, transName);
				//else
				//	connection.rollback((Savepoint) savepoints.get(transName));
			}
		}
	}
	
	public static class RecordBuffer 
	{
		private Hashtable values = new Hashtable();
		private Connection connection;
		
		public RecordBuffer(Connection connection) 
		{ 
			this.connection = connection; 
		}
		
		public void setValue(String name, Object value)
		{
			if (value != null)
				values.put(name, value);
		}
		
		public Object getValue(String name)
		{
			return values.get(name);
		}
		
		private static void setParam(PreparedStatement statement, int index, Object o) throws java.sql.SQLException 
		{
			Command.FieldValue fieldValue = (Command.FieldValue)(o);

			if (fieldValue.value == null)
			{
				int type = java.sql.Types.VARCHAR;
				if( fieldValue.type != java.sql.Types.JAVA_OBJECT)
					type = fieldValue.type; // use meta type

				statement.setNull(index, type);
			}
			else if (fieldValue.value instanceof java.util.Calendar)
			{
				java.util.Calendar cal = (java.util.Calendar)(fieldValue.value);
				setParameter(statement, index, cal);
			}	
			else if (fieldValue.value instanceof java.math.BigDecimal && statement.getConnection().getMetaData().getDatabaseProductName().equals("ACCESS"))
			{
				String s = ((java.math.BigDecimal)(fieldValue.value)).toString();
				
				// remove trailing decimal zeros
				int l = s.length();
				if (s.indexOf(".") != -1)
				{
					while (s.charAt(l-1) == '0')
						l--;
					if (s.charAt(l-1) == '.')
						l--;
				}
				s = s.substring(0, l);
				
				statement.setString(index, s);
			}
			else if (fieldValue.value instanceof java.lang.Long && statement.getConnection().getMetaData().getDatabaseProductName().equals("ACCESS"))
			{
				statement.setInt(index, ((Long)(fieldValue.value)).intValue());
			}
			else if (fieldValue.value instanceof java.math.BigInteger && statement.getConnection().getMetaData().getDatabaseProductName().equals("MySQL"))
			{
				String s = ((java.math.BigInteger)(fieldValue.value)).toString();
				statement.setString(index, s);
			}
			else if (fieldValue.value instanceof com.altova.types.DateTime)
			{
				com.altova.types.DateTime dt = (com.altova.types.DateTime)(fieldValue.value);
				setParameter(statement, index, dt);		
			}	
			else if (fieldValue.value instanceof byte[]) 
			{
				byte[] value = (byte[])(fieldValue.value); 
				setParameter(statement, index, value);		
			}
			else
			{
				if( fieldValue.type != java.sql.Types.JAVA_OBJECT )
				{
					if( fieldValue.scale > 0 ) 
					{
						statement.setObject(index, fieldValue.value, fieldValue.type, fieldValue.scale);
					}
					else if( fieldValue.length > 0 ) 
					{
						statement.setObject(index, fieldValue.value, fieldValue.type, fieldValue.length);
					}
					else
					{
						statement.setObject(index, fieldValue.value, fieldValue.type);
					}
				}
				else
				{
					statement.setObject(index, fieldValue.value);
				}
			}
		}
		
		private static void setParameter(PreparedStatement statement, int index, byte[] val) throws java.sql.SQLException
		{
			String dbname = statement.getConnection().getMetaData().getDatabaseProductName();
			if( (dbname.equals("Microsoft SQL Server")) )
			{
				statement.setBytes( index, val );
			}
			else
			{
				java.io.InputStream stream = new java.io.ByteArrayInputStream(val);
				statement.setBinaryStream( index, stream, val.length );
			}
		}

		private static void setParameter(PreparedStatement stmt, int index, com.altova.types.DateTime val) throws java.sql.SQLException
		{
			String dbname = stmt.getConnection().getMetaData().getDatabaseProductName();
			if( (dbname.equals("Microsoft SQL Server")) )
			{
				val.setHasTimezone(com.altova.types.CalendarBase.TZ_MISSING);
				String x = val.toString();
				stmt.setString(index, x);
				return;
			}
			if( (dbname.equals("Oracle")) )
			{
				String x = val.toString();
				stmt.setString(index, x);
				return;
			}
			if( (dbname.startsWith("DB2")) )
			{
				if( (val.getYear() == 1) && (val.getMonth() == 1) && (val.getDay() == 1) )
				{// looks like a time
					long milli = val.getValue().getTimeInMillis();
					java.sql.Time time = new java.sql.Time(milli);
					stmt.setTime( index, time/*, val.getValue()*/ );
					return;
				}
				if( (val.getHour() == 0) && (val.getMinute() == 0) && (val.getSecond() == 0) && (val.getMillisecond() == 0) )
				{// looks like a date
					long milli = val.getValue().getTimeInMillis();
					java.sql.Date date = new java.sql.Date(milli);					
					stmt.setDate( index, date/*, val.getValue()*/ );
					return;
				}
				
				// remove timezone for timestamp values (no UTC conversion)
				val.setHasTimezone(com.altova.types.CalendarBase.TZ_MISSING);
				long milli = val.getValue().getTimeInMillis();
				stmt.setTimestamp(index, new java.sql.Timestamp(milli));
				return;
			}
			setParameter( stmt, index, val.getValue() );
		}
		
		private static void setParameter(PreparedStatement stmt, int index, java.util.Calendar val) throws java.sql.SQLException
		{
			//	long milli = val.getTimeInMillis();
			//	int offset = val.getTimeZone().getRawOffset();
			//	stmt.setTimestamp(index, new java.sql.Timestamp(milli - offset) );
			long milli = val.getTimeInMillis();
			stmt.setTimestamp(index, new java.sql.Timestamp(milli), val );
		}
		
		
		public boolean execute(Command command, TransactionHelper transactionHelper) throws java.sql.SQLException
		{
			boolean bRet = false;
			
			PreparedStatement statement = connection.prepareStatement(command.getStatement());
						
			// params
			try
			{
				for (int i=0; i < command.getParameters().size(); ++i)
				{
					Object param = command.getParameters().get(i);
					Command.FieldValue fieldValue = (Command.FieldValue)(param);
					
					if (fieldValue.value instanceof ReadBack)
					{
						ReadBack readBack = (ReadBack)(fieldValue.value);
						fieldValue.value = values.get((readBack).getName());
					}
					
					setParam(statement, i+1, fieldValue);
				}
				
				if (command.isAutoReadFieldsIntoBuffer()) // we are interested in the result
				{
					try
					{
						ResultSet result = statement.executeQuery();
						if (result.next())
						{
							java.sql.ResultSetMetaData meta = result.getMetaData(); 
							for (int i=0; i<meta.getColumnCount(); ++i)
								setValue(meta.getColumnName(i+1), result.getObject(i+1));
							bRet = true;
						}
					}
					catch (java.sql.SQLException e)
					{
					}
				}
				else // or we are not
				{
					try
					{
						boolean b = statement.execute();
						if (b) // has resultset?
							bRet = statement.getResultSet().next(); // at least one row
						else 
							bRet = statement.getUpdateCount() > 0; // at least one row affected
					}
					catch (java.sql.SQLException e)
					{
						// DB2 special handling
						if (e.getMessage().equals("No data found") &&
							statement.getConnection().getMetaData().getDatabaseProductName().indexOf("DB2") != -1 &&
							statement.getConnection().getMetaData().getDriverName().indexOf("DB2CLI") != -1)
							bRet = false;
						else
							throw e;
					}
				}
			}
			finally
			{
				statement.close();
			}
			return bRet;
		}
		
		public boolean execute(java.util.ArrayList commands, TransactionHelper transactionHelper) throws java.sql.SQLException
		{
			boolean b = false;
			for (int i = 0; i < commands.size(); i++)
			{
				b = execute((Command) commands.get(i), transactionHelper);
			}
			return b;
		}
				
		public Connection getConnection()
		{
			return connection;
		}
		
		public int getNumberOfRowsToDelete() 
		{ 
			double d = Double.parseDouble(values.get("MAPFORCE_DEL_ROWS").toString());
			return (int) d;
		}
	}
}

