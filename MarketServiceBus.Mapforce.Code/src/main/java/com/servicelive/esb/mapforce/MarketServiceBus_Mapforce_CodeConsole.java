/**
 * MarketServiceBus_Mapforce_CodeConsole.java
 *
 * This file was generated by MapForce 2011sp1.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the MapForce Documentation for further details.
 * http://www.altova.com/mapforce
 */


package com.servicelive.esb.mapforce;

import com.altova.types.*;


public class MarketServiceBus_Mapforce_CodeConsole {

	public static void main(String[] args) {
		System.out.println("MarketServiceBus.Mapforce.Code Application");

		java.util.Hashtable	mapArguments = new java.util.Hashtable();
		if( args.length <= 1 )	{
			System.out.println();
			System.out.println( "WARNING: No parameters given!");
			System.out.println( "SYNTAX: java com.mapforce.MarketServiceBus_Mapforce_CodeConsole /integrationId ... /buyerResourceId ... /integrationId ... /integrationId ... /batchId ... /batchId ... /integrationId ... /integrationId ... ");
			System.out.println( "SYNTAX: ant -Dcmdline=\"/integrationId ... /buyerResourceId ... /integrationId ... /integrationId ... /batchId ... /batchId ... /integrationId ... /integrationId ... \"");
			System.out.println( "Note: If you want to use spaces as values write them in-between double quotes." );
			System.out.println();
		}
		else
		{
			for( int i = 0; i < args.length; i++ )
			{
				String sName = args[ i ];
				if( sName.substring( 0, 1 ).equals( "/" )  &&  ( i + 1 ) < args.length )
					mapArguments.put( sName.substring( 1, sName.length() ), args[ ++i ] );
			}
		}

		try { // Assurant
			TraceTargetConsole ttc = new TraceTargetConsole();


			AssurantMapToServiceLiveIntegrationDb AssurantMapToServiceLiveIntegrationDbObject = new AssurantMapToServiceLiveIntegrationDb();

			Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
			Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");

			AssurantMapToServiceLiveIntegrationDbObject.registerTraceTarget(ttc);
	
			if(!mapArguments.containsKey("integrationId"))
			{
				System.out.println("Missing argument integrationId");
				System.exit(1);
			}
			if(!mapArguments.containsKey("buyerResourceId"))
			{
				System.out.println("Missing argument buyerResourceId");
				System.exit(1);
			}

			// run mapping
			//
			// you have different options to provide mapping input and output:
			//
			// files using file names (available for XML, text, and Excel):
			//   com.altova.io.FileInput(String filename)
			//   com.altova.io.FileOutput(String filename)
			//
			// streams (available for XML, text, and Excel):
			//   com.altova.io.StreamInput(java.io.InputStream stream)
			//   com.altova.io.StreamOutput(java.io.OutputStream stream)
			//
			// strings (available for XML and text):
			//   com.altova.io.StringInput(String xmlcontent)
			//   com.altova.io.StringOutput()	(call getContent() after run() to get StringBuffer with content)
			//
			// Java IO reader/writer (available for XML and text):
			//   com.altova.io.ReaderInput(java.io.Reader reader)
			//   com.altova.io.WriterOutput(java.io.Writer writer)
			//
			// DOM documents (for XML only):
			//   com.altova.io.DocumentInput(org.w3c.dom.Document document)
			//   com.altova.io.DocumentOutput(org.w3c.dom.Document document)
			// 
			// By default, run will close all inputs and outputs. If you do not want this,
			// call the following function:
			// AssurantMapToServiceLiveIntegrationDbObject.setCloseObjectsAfterRun(false);

			{
				com.altova.io.Input AssurantSource = com.altova.io.StreamInput.createInput("../sample-files/Assurant-Sample.done");			

				AssurantMapToServiceLiveIntegrationDbObject.run(
						AssurantSource,
						java.sql.DriverManager.getConnection(
							"jdbc:odbc:SLIntegration",
							"supply_usr",
							"supply"),
						com.altova.CoreTypes.castToLong((String)mapArguments.get("integrationId")),
						com.altova.CoreTypes.castToLong((String)mapArguments.get("buyerResourceId")),
						java.sql.DriverManager.getConnection(
							"jdbc:odbc:SLIntegration",
							"supply_usr",
							"supply"));
			}



			System.out.println("Finished");
		} 
		catch (com.altova.UserException ue) 
		{
			System.out.print("USER EXCEPTION:");
			System.out.println( ue.getMessage() );
			System.exit(1);
		}
		
		catch (com.altova.AltovaException e)
		{
			System.out.print("ERROR: ");
			System.out.println( e.getMessage() );
			if (e.getInnerException() != null)
			{
				System.out.print("Inner exception: ");
				System.out.println(e.getInnerException().getMessage());
				if (e.getInnerException().getCause() != null)
				{
					System.out.print("Cause: ");
					System.out.println(e.getInnerException().getCause().getMessage());
				}
			}
			System.out.println("\nStack Trace: ");
			e.printStackTrace();
			System.exit(1);
		}
		
		catch (Exception e) {
			System.out.print("ERROR: ");
			System.out.println( e.getMessage() );
			System.out.println("\nStack Trace: ");
			e.printStackTrace();
			System.exit(1);
		}

		try { // HSRNewRequest
			TraceTargetConsole ttc = new TraceTargetConsole();


			HSRNewRequestMapToServiceLiveIntegrationDb3 HSRNewRequestMapToServiceLiveIntegrationDb3Object = new HSRNewRequestMapToServiceLiveIntegrationDb3();

			Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
			Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");

			HSRNewRequestMapToServiceLiveIntegrationDb3Object.registerTraceTarget(ttc);
	
			if(!mapArguments.containsKey("integrationId"))
			{
				System.out.println("Missing argument integrationId");
				System.exit(1);
			}

			// run mapping
			//
			// you have different options to provide mapping input and output:
			//
			// files using file names (available for XML, text, and Excel):
			//   com.altova.io.FileInput(String filename)
			//   com.altova.io.FileOutput(String filename)
			//
			// streams (available for XML, text, and Excel):
			//   com.altova.io.StreamInput(java.io.InputStream stream)
			//   com.altova.io.StreamOutput(java.io.OutputStream stream)
			//
			// strings (available for XML and text):
			//   com.altova.io.StringInput(String xmlcontent)
			//   com.altova.io.StringOutput()	(call getContent() after run() to get StringBuffer with content)
			//
			// Java IO reader/writer (available for XML and text):
			//   com.altova.io.ReaderInput(java.io.Reader reader)
			//   com.altova.io.WriterOutput(java.io.Writer writer)
			//
			// DOM documents (for XML only):
			//   com.altova.io.DocumentInput(org.w3c.dom.Document document)
			//   com.altova.io.DocumentOutput(org.w3c.dom.Document document)
			// 
			// By default, run will close all inputs and outputs. If you do not want this,
			// call the following function:
			// HSRNewRequestMapToServiceLiveIntegrationDb3Object.setCloseObjectsAfterRun(false);

			{
				com.altova.io.Input HSRNewRequestSource = com.altova.io.StreamInput.createInput("../sample-files/HSR-NewRequest.txt");			

				HSRNewRequestMapToServiceLiveIntegrationDb3Object.run(
						HSRNewRequestSource,
						java.sql.DriverManager.getConnection(
							"jdbc:odbc:SLIntegration",
							"supply_usr",
							"supply"),
						com.altova.CoreTypes.castToLong((String)mapArguments.get("integrationId")),
						java.sql.DriverManager.getConnection(
							"jdbc:odbc:SLIntegration",
							"supply_usr",
							"supply"));
			}



			System.out.println("Finished");
		} 
		catch (com.altova.UserException ue) 
		{
			System.out.print("USER EXCEPTION:");
			System.out.println( ue.getMessage() );
			System.exit(1);
		}
		
		catch (com.altova.AltovaException e)
		{
			System.out.print("ERROR: ");
			System.out.println( e.getMessage() );
			if (e.getInnerException() != null)
			{
				System.out.print("Inner exception: ");
				System.out.println(e.getInnerException().getMessage());
				if (e.getInnerException().getCause() != null)
				{
					System.out.print("Cause: ");
					System.out.println(e.getInnerException().getCause().getMessage());
				}
			}
			System.out.println("\nStack Trace: ");
			e.printStackTrace();
			System.exit(1);
		}
		
		catch (Exception e) {
			System.out.print("ERROR: ");
			System.out.println( e.getMessage() );
			System.out.println("\nStack Trace: ");
			e.printStackTrace();
			System.exit(1);
		}

		try { // HSRUpdateRequest
			TraceTargetConsole ttc = new TraceTargetConsole();


			HSRUpdateRequestMapToServiceLiveIntegrationDb5 HSRUpdateRequestMapToServiceLiveIntegrationDb5Object = new HSRUpdateRequestMapToServiceLiveIntegrationDb5();

			Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
			Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");

			HSRUpdateRequestMapToServiceLiveIntegrationDb5Object.registerTraceTarget(ttc);
	
			if(!mapArguments.containsKey("integrationId"))
			{
				System.out.println("Missing argument integrationId");
				System.exit(1);
			}

			// run mapping
			//
			// you have different options to provide mapping input and output:
			//
			// files using file names (available for XML, text, and Excel):
			//   com.altova.io.FileInput(String filename)
			//   com.altova.io.FileOutput(String filename)
			//
			// streams (available for XML, text, and Excel):
			//   com.altova.io.StreamInput(java.io.InputStream stream)
			//   com.altova.io.StreamOutput(java.io.OutputStream stream)
			//
			// strings (available for XML and text):
			//   com.altova.io.StringInput(String xmlcontent)
			//   com.altova.io.StringOutput()	(call getContent() after run() to get StringBuffer with content)
			//
			// Java IO reader/writer (available for XML and text):
			//   com.altova.io.ReaderInput(java.io.Reader reader)
			//   com.altova.io.WriterOutput(java.io.Writer writer)
			//
			// DOM documents (for XML only):
			//   com.altova.io.DocumentInput(org.w3c.dom.Document document)
			//   com.altova.io.DocumentOutput(org.w3c.dom.Document document)
			// 
			// By default, run will close all inputs and outputs. If you do not want this,
			// call the following function:
			// HSRUpdateRequestMapToServiceLiveIntegrationDb5Object.setCloseObjectsAfterRun(false);

			{
				com.altova.io.Input HSRUpdateRequestSource = com.altova.io.StreamInput.createInput("../sample-files/HSR-UpdateRequest2.txt");			

				HSRUpdateRequestMapToServiceLiveIntegrationDb5Object.run(
						HSRUpdateRequestSource,
						java.sql.DriverManager.getConnection(
							"jdbc:odbc:SLIntegration",
							"supply_usr",
							"supply"),
						com.altova.CoreTypes.castToLong((String)mapArguments.get("integrationId")),
						java.sql.DriverManager.getConnection(
							"jdbc:odbc:SLIntegration",
							"supply_usr",
							"supply"));
			}



			System.out.println("Finished");
		} 
		catch (com.altova.UserException ue) 
		{
			System.out.print("USER EXCEPTION:");
			System.out.println( ue.getMessage() );
			System.exit(1);
		}
		
		catch (com.altova.AltovaException e)
		{
			System.out.print("ERROR: ");
			System.out.println( e.getMessage() );
			if (e.getInnerException() != null)
			{
				System.out.print("Inner exception: ");
				System.out.println(e.getInnerException().getMessage());
				if (e.getInnerException().getCause() != null)
				{
					System.out.print("Cause: ");
					System.out.println(e.getInnerException().getCause().getMessage());
				}
			}
			System.out.println("\nStack Trace: ");
			e.printStackTrace();
			System.exit(1);
		}
		
		catch (Exception e) {
			System.out.print("ERROR: ");
			System.out.println( e.getMessage() );
			System.out.println("\nStack Trace: ");
			e.printStackTrace();
			System.exit(1);
		}

		try { // NPSCallClose
			TraceTargetConsole ttc = new TraceTargetConsole();


			NPSCallCloseMapToNPSCallCloseUpdate NPSCallCloseMapToNPSCallCloseUpdateObject = new NPSCallCloseMapToNPSCallCloseUpdate();

			Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");

			NPSCallCloseMapToNPSCallCloseUpdateObject.registerTraceTarget(ttc);
	
			if(!mapArguments.containsKey("batchId"))
			{
				System.out.println("Missing argument batchId");
				System.exit(1);
			}

			// run mapping
			//
			// you have different options to provide mapping input and output:
			//
			// files using file names (available for XML, text, and Excel):
			//   com.altova.io.FileInput(String filename)
			//   com.altova.io.FileOutput(String filename)
			//
			// streams (available for XML, text, and Excel):
			//   com.altova.io.StreamInput(java.io.InputStream stream)
			//   com.altova.io.StreamOutput(java.io.OutputStream stream)
			//
			// strings (available for XML and text):
			//   com.altova.io.StringInput(String xmlcontent)
			//   com.altova.io.StringOutput()	(call getContent() after run() to get StringBuffer with content)
			//
			// Java IO reader/writer (available for XML and text):
			//   com.altova.io.ReaderInput(java.io.Reader reader)
			//   com.altova.io.WriterOutput(java.io.Writer writer)
			//
			// DOM documents (for XML only):
			//   com.altova.io.DocumentInput(org.w3c.dom.Document document)
			//   com.altova.io.DocumentOutput(org.w3c.dom.Document document)
			// 
			// By default, run will close all inputs and outputs. If you do not want this,
			// call the following function:
			// NPSCallCloseMapToNPSCallCloseUpdateObject.setCloseObjectsAfterRun(false);

			{
				com.altova.io.Output NPSCallCloseUpdate2Target = new com.altova.io.FileOutput("NPSCallCloseUpdate.xml");

				NPSCallCloseMapToNPSCallCloseUpdateObject.run(
						java.sql.DriverManager.getConnection(
							"jdbc:odbc:SLIntegration",
							"supply_usr",
							"supply"),
						com.altova.CoreTypes.castToLong((String)mapArguments.get("batchId")),
						NPSCallCloseUpdate2Target);
			}



			System.out.println("Finished");
		} 
		catch (com.altova.UserException ue) 
		{
			System.out.print("USER EXCEPTION:");
			System.out.println( ue.getMessage() );
			System.exit(1);
		}
		
		catch (com.altova.AltovaException e)
		{
			System.out.print("ERROR: ");
			System.out.println( e.getMessage() );
			if (e.getInnerException() != null)
			{
				System.out.print("Inner exception: ");
				System.out.println(e.getInnerException().getMessage());
				if (e.getInnerException().getCause() != null)
				{
					System.out.print("Cause: ");
					System.out.println(e.getInnerException().getCause().getMessage());
				}
			}
			System.out.println("\nStack Trace: ");
			e.printStackTrace();
			System.exit(1);
		}
		
		catch (Exception e) {
			System.out.print("ERROR: ");
			System.out.println( e.getMessage() );
			System.out.println("\nStack Trace: ");
			e.printStackTrace();
			System.exit(1);
		}

		try { // NPSCancellation
			TraceTargetConsole ttc = new TraceTargetConsole();


			NPSCancellationMapToRI_Input NPSCancellationMapToRI_InputObject = new NPSCancellationMapToRI_Input();

			Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");

			NPSCancellationMapToRI_InputObject.registerTraceTarget(ttc);
	
			if(!mapArguments.containsKey("batchId"))
			{
				System.out.println("Missing argument batchId");
				System.exit(1);
			}

			// run mapping
			//
			// you have different options to provide mapping input and output:
			//
			// files using file names (available for XML, text, and Excel):
			//   com.altova.io.FileInput(String filename)
			//   com.altova.io.FileOutput(String filename)
			//
			// streams (available for XML, text, and Excel):
			//   com.altova.io.StreamInput(java.io.InputStream stream)
			//   com.altova.io.StreamOutput(java.io.OutputStream stream)
			//
			// strings (available for XML and text):
			//   com.altova.io.StringInput(String xmlcontent)
			//   com.altova.io.StringOutput()	(call getContent() after run() to get StringBuffer with content)
			//
			// Java IO reader/writer (available for XML and text):
			//   com.altova.io.ReaderInput(java.io.Reader reader)
			//   com.altova.io.WriterOutput(java.io.Writer writer)
			//
			// DOM documents (for XML only):
			//   com.altova.io.DocumentInput(org.w3c.dom.Document document)
			//   com.altova.io.DocumentOutput(org.w3c.dom.Document document)
			// 
			// By default, run will close all inputs and outputs. If you do not want this,
			// call the following function:
			// NPSCancellationMapToRI_InputObject.setCloseObjectsAfterRun(false);

			{
				com.altova.io.Output RI_Input2Target = new com.altova.io.FileOutput("../sample-files/RI-Sample.startProcessGW.xml");

				NPSCancellationMapToRI_InputObject.run(
						java.sql.DriverManager.getConnection(
							"jdbc:odbc:SLIntegration",
							"supply_usr",
							"supply"),
						com.altova.CoreTypes.castToLong((String)mapArguments.get("batchId")),
						RI_Input2Target);
			}



			System.out.println("Finished");
		} 
		catch (com.altova.UserException ue) 
		{
			System.out.print("USER EXCEPTION:");
			System.out.println( ue.getMessage() );
			System.exit(1);
		}
		
		catch (com.altova.AltovaException e)
		{
			System.out.print("ERROR: ");
			System.out.println( e.getMessage() );
			if (e.getInnerException() != null)
			{
				System.out.print("Inner exception: ");
				System.out.println(e.getInnerException().getMessage());
				if (e.getInnerException().getCause() != null)
				{
					System.out.print("Cause: ");
					System.out.println(e.getInnerException().getCause().getMessage());
				}
			}
			System.out.println("\nStack Trace: ");
			e.printStackTrace();
			System.exit(1);
		}
		
		catch (Exception e) {
			System.out.print("ERROR: ");
			System.out.println( e.getMessage() );
			System.out.println("\nStack Trace: ");
			e.printStackTrace();
			System.exit(1);
		}

		try { // NPSCloseAudit
			TraceTargetConsole ttc = new TraceTargetConsole();


			NPSCloseAuditMapToServiceLiveIntegrationDb8 NPSCloseAuditMapToServiceLiveIntegrationDb8Object = new NPSCloseAuditMapToServiceLiveIntegrationDb8();

			Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
			Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");

			NPSCloseAuditMapToServiceLiveIntegrationDb8Object.registerTraceTarget(ttc);
	
			if(!mapArguments.containsKey("integrationId"))
			{
				System.out.println("Missing argument integrationId");
				System.exit(1);
			}

			// run mapping
			//
			// you have different options to provide mapping input and output:
			//
			// files using file names (available for XML, text, and Excel):
			//   com.altova.io.FileInput(String filename)
			//   com.altova.io.FileOutput(String filename)
			//
			// streams (available for XML, text, and Excel):
			//   com.altova.io.StreamInput(java.io.InputStream stream)
			//   com.altova.io.StreamOutput(java.io.OutputStream stream)
			//
			// strings (available for XML and text):
			//   com.altova.io.StringInput(String xmlcontent)
			//   com.altova.io.StringOutput()	(call getContent() after run() to get StringBuffer with content)
			//
			// Java IO reader/writer (available for XML and text):
			//   com.altova.io.ReaderInput(java.io.Reader reader)
			//   com.altova.io.WriterOutput(java.io.Writer writer)
			//
			// DOM documents (for XML only):
			//   com.altova.io.DocumentInput(org.w3c.dom.Document document)
			//   com.altova.io.DocumentOutput(org.w3c.dom.Document document)
			// 
			// By default, run will close all inputs and outputs. If you do not want this,
			// call the following function:
			// NPSCloseAuditMapToServiceLiveIntegrationDb8Object.setCloseObjectsAfterRun(false);

			{
				com.altova.io.Input NPSCloseAudit_AUD2Source = com.altova.io.StreamInput.createInput("../../../../appl/sl/iss/13278-callclose.npsCallCloseAudit");

				NPSCloseAuditMapToServiceLiveIntegrationDb8Object.run(
						NPSCloseAudit_AUD2Source,
						java.sql.DriverManager.getConnection(
							"jdbc:odbc:SLIntegration",
							"supply_usr",
							"supply"),
						com.altova.CoreTypes.castToLong((String)mapArguments.get("integrationId")),
						java.sql.DriverManager.getConnection(
							"jdbc:odbc:SLIntegration",
							"supply_usr",
							"supply"));
			}



			System.out.println("Finished");
		} 
		catch (com.altova.UserException ue) 
		{
			System.out.print("USER EXCEPTION:");
			System.out.println( ue.getMessage() );
			System.exit(1);
		}
		
		catch (com.altova.AltovaException e)
		{
			System.out.print("ERROR: ");
			System.out.println( e.getMessage() );
			if (e.getInnerException() != null)
			{
				System.out.print("Inner exception: ");
				System.out.println(e.getInnerException().getMessage());
				if (e.getInnerException().getCause() != null)
				{
					System.out.print("Cause: ");
					System.out.println(e.getInnerException().getCause().getMessage());
				}
			}
			System.out.println("\nStack Trace: ");
			e.printStackTrace();
			System.exit(1);
		}
		
		catch (Exception e) {
			System.out.print("ERROR: ");
			System.out.println( e.getMessage() );
			System.out.println("\nStack Trace: ");
			e.printStackTrace();
			System.exit(1);
		}

		try { // SearsRI
			TraceTargetConsole ttc = new TraceTargetConsole();


			SearsRIMapToServiceLiveIntegrationDb9 SearsRIMapToServiceLiveIntegrationDb9Object = new SearsRIMapToServiceLiveIntegrationDb9();

			Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
			Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");

			SearsRIMapToServiceLiveIntegrationDb9Object.registerTraceTarget(ttc);
	
			if(!mapArguments.containsKey("integrationId"))
			{
				System.out.println("Missing argument integrationId");
				System.exit(1);
			}

			// run mapping
			//
			// you have different options to provide mapping input and output:
			//
			// files using file names (available for XML, text, and Excel):
			//   com.altova.io.FileInput(String filename)
			//   com.altova.io.FileOutput(String filename)
			//
			// streams (available for XML, text, and Excel):
			//   com.altova.io.StreamInput(java.io.InputStream stream)
			//   com.altova.io.StreamOutput(java.io.OutputStream stream)
			//
			// strings (available for XML and text):
			//   com.altova.io.StringInput(String xmlcontent)
			//   com.altova.io.StringOutput()	(call getContent() after run() to get StringBuffer with content)
			//
			// Java IO reader/writer (available for XML and text):
			//   com.altova.io.ReaderInput(java.io.Reader reader)
			//   com.altova.io.WriterOutput(java.io.Writer writer)
			//
			// DOM documents (for XML only):
			//   com.altova.io.DocumentInput(org.w3c.dom.Document document)
			//   com.altova.io.DocumentOutput(org.w3c.dom.Document document)
			// 
			// By default, run will close all inputs and outputs. If you do not want this,
			// call the following function:
			// SearsRIMapToServiceLiveIntegrationDb9Object.setCloseObjectsAfterRun(false);

			{
				com.altova.io.Input RI_Input3Source = com.altova.io.StreamInput.createInput("../sample-files/RI-Sample.startProcessGW.xml");

				SearsRIMapToServiceLiveIntegrationDb9Object.run(
						RI_Input3Source,
						java.sql.DriverManager.getConnection(
							"jdbc:odbc:SLIntegration",
							"supply_usr",
							"supply"),
						com.altova.CoreTypes.castToLong((String)mapArguments.get("integrationId")),
						java.sql.DriverManager.getConnection(
							"jdbc:odbc:SLIntegration",
							"supply_usr",
							"supply"));
			}



			System.out.println("Finished");
		} 
		catch (com.altova.UserException ue) 
		{
			System.out.print("USER EXCEPTION:");
			System.out.println( ue.getMessage() );
			System.exit(1);
		}
		
		catch (com.altova.AltovaException e)
		{
			System.out.print("ERROR: ");
			System.out.println( e.getMessage() );
			if (e.getInnerException() != null)
			{
				System.out.print("Inner exception: ");
				System.out.println(e.getInnerException().getMessage());
				if (e.getInnerException().getCause() != null)
				{
					System.out.print("Cause: ");
					System.out.println(e.getInnerException().getCause().getMessage());
				}
			}
			System.out.println("\nStack Trace: ");
			e.printStackTrace();
			System.exit(1);
		}
		
		catch (Exception e) {
			System.out.print("ERROR: ");
			System.out.println( e.getMessage() );
			System.out.println("\nStack Trace: ");
			e.printStackTrace();
			System.exit(1);
		}

	}
}


class TraceTargetConsole implements com.altova.TraceTarget {
	public void writeTrace(String info) {
		System.out.println(info);
	}
}
